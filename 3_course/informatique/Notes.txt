• Librairie < framework < package < class < objet

• lettre(char) > mot(word) > phrase(doubleword) > mémo(longword)
• instruction , expression, opération, opérateur
• on dirait qu'un pointeur sert à prendre la valeur d'une autre variable alors qu'un référecement sert plutôt à en prendre son adresse.
•Quand une fonction prend un pointeur  en entrée  ce pointeur indique  là où la valeur sera stockée.
Dans le cas d'une variable classique on ne sait pas où la valeur sera renvoyé.
•copie[100] = {0}; initialiser le tableau à zéro partout. Pas possible avec d'autres valeurs.

La méthode  WriteLine  est « statique », ce qui signifie que vous n'avez pas besoin d'instancier un objet pour l'utiliser. C'est pour cela que vous pouvez appeler la méthode directement sur la classe  System

chaîne de compilation ARM permet de construire des applications écrites en C, C++ et assembleur sur les processeurs ARM. La chaîne est composée :
d’un compilateur (armcc) pour les langages C et C++ ;
d’un assembleur (armasm) pour traiter directement du langage d’assemblage propre aux architectures ARM ;
d’un éditeur de liens (linker) (armlink) qui permet de lier les différents objets pour produire un exécutable ;
un outil (armar) permettant de créer des archives au format ELF afin de construire des librairies pré-compilées ;
un utilitaire (fromelf) permettant de travailler et d'avoir des informations sur les archives au format ELF telles que la taille du code ou des données.
Enfin, pour ce qui est du débogueur, l'IDE µVision met à disposition un outil intégré permettant de suivre pas à pas l'exécution d'un programme aussi bien en simulé que sur la cible réelle. L'IDE offre aussi un outil pour charger (loader) le code sur la cible suivant différents formats de fichiers binaires compilés.
Si vous souhaitez utiliser la carte NUCLEO pour le développement de vos applications, il vous faut aussi charger le driver Windows ST-LINK/V2.




printf("L'adresse de la variable age est : %p", &age);

Comme notre pointeur pointeurSurAge va contenir l'adresse de la variable age  (qui est de type int  ),
 alors mon pointeur doit être de type int*  !
Si ma variable age avait été de type double  , alors j'aurais dû écrire double *monPointeur  .

Le mot clé STATIC sur une variable au sein d'une fonction l'empêche d'être détruite(comportement normal) à la
fin de la fonction. Donc si la fonction est répéter il y aura une incrémentation (dans le cas d'une fonction qui effectue une opération somme) plutot qu'une répétion (sans STATIC)


Les contantes prédéfines & Les directives préprocesseurs signifie en faite préexécution sur le reste programme. grace au # les instruction sont exécuté avant tout. On le qualifide de préCPU car # sert à effectuer une substituton et n'est pas compilé.

Rendre son code source modulaire ça veut dire le diviser (avec plusieurs *.C et *.H), le rendre le plus clair possible.

Commençons par ajouter un fichier *.C qui contiendra seulement la fonction triple comme ci-dessous.

Notez que dans main.c j'ai l'habitude de garder que la fonction main.

Pour allouer dynamiquement en C++, on utilisera l’opérateur new.
Celui-ci renvoyant une adresse où est crée la variable en question, il
nous faudra un pointeur pour la conserver.
Manipuler ce pointeur, reviendra à manipuler la variable allouée
dynamiquement.
Pour libérer de la mémoire allouée dynamiquement en C++, on
utilisera l’opérateur delete.



int *monPointeur = NULL;
Là, vous avez un pointeur initialisé à NULL  . Comme ça, vous saurez dans la suite de votre programme que votre pointeur ne contient aucune adresse.
Que se passe-t-il ?
Ce code va réserver une case en mémoire comme si vous aviez créé une variable normale.
Cependant, et c'est ce qui change, la valeur du pointeur est faite pour contenir une adresse. L'adresse… d'une autre variable.
Vous savez maintenant comment indiquer l'adresse d'une variable (au lieu de sa valeur) en utilisant le symbole &  ,


 size_t strlen(const char* chaine);
La fonction prend un paramètre de type const char*  : là où sera renvoyée la valeur mais inchangée.  
Le const(  qui signifie constante) fait que la fonction strlen "s'interdit" en quelque sorte de modifier votre chaîne. Quand vous voyez un const  , vous savez que la variable n'est pas modifiée par la fonction, elle est juste lue.


char* strchr(const char* chaine, int caractereARechercher);
La fonction renvoie un pointeur vers le premier caractère qu'elle a trouvé, c'est-à-dire qu'elle renvoie l'adresse (en provenance de la valeur) de ce caractère dans la mémoire. Elle renvoie NULL si elle n'a rien trouvé.



Lorsque vous programmez pour l’embarqué, vous allez compiler et exécuter votre code sur deux machines différentes, qui n’ont pas la même micro-architecture. C’est la grande différence entre la programmation usuelle sur une machine du bureau et la programmation pour l’embarqué ! On parle alors de compilation croisée (cross compilation).


C# : Il existe deux types de classes :
Les classes de plan, qui sont utilisées comme plans pour l'instanciation des objets.
Les classes utilitaires, qui contiennent des méthodes statiques pouvant être appelées directement sur la classe.


On peut trouver une seule case mémoire mais avec deux étiquettes(identificateur) qui lui sont accrochées.
Au niveau du code, on utilise une esperluette ( &  ) pour déclarer une référence(deuxième identificateur) sur une variable.
int& variable(référence);

























































