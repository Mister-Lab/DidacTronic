Alors, on peut faire confiance à celui qui créé le document XML pour respecter des règles explicites ou implicites mais le mieux c'est encore de décrire ces règles dans un document. Document qui pourra servir au contrôle automatique du document XML par un outil.
Pour définir une DTD externe, il suffit d'écrire <!DOCTYPE racine SYSTEM "nomdufichier.dtd"> juste après <?xml version="1.0" ?>(prologue) où racine est le nom de la balise racine de l'arbre XML.
XML and HTML were designed with different goals:

XML was designed to carry data - with focus on what data is
HTML was designed to display data - with focus on how data looks
XML tags are not predefined like HTML tags are




Int a; "reçois cette valeur ICI/tient voici la valeur" donc je te donne une valeur
int *a; "prend cette valeur LA/va chercher la valeur" donc je te donne une variable
int &a; "reçois cette valeur ICI qui est la même que LA"


• Librairie < framework < package < class < objet

• lettre(char) > mot(word) > phrase(doubleword) > mémo(longword)
• instruction , expression, opération, opérateur
• on dirait qu'un pointeur sert à prendre la valeur d'une autre variable alors qu'un référecement sert plutôt à en prendre son adresse.
•Quand une fonction prend un pointeur  en entrée  ce pointeur indique  là où la valeur sera stockée.
Dans le cas d'une variable classique on ne sait pas où la valeur sera renvoyé.
•copie[100] = {0}; initialiser le tableau à zéro partout. Pas possible avec d'autres valeurs.

La méthode  WriteLine  est « statique », ce qui signifie que vous n'avez pas besoin d'instancier un objet pour l'utiliser. C'est pour cela que vous pouvez appeler la méthode directement sur la classe  System

chaîne de compilation ARM permet de construire des applications écrites en C, C++ et assembleur sur les processeurs ARM. La chaîne est composée :
d’un compilateur (armcc) pour les langages C et C++ ;
d’un assembleur (armasm) pour traiter directement du langage d’assemblage propre aux architectures ARM ;
d’un éditeur de liens (linker) (armlink) qui permet de lier les différents objets pour produire un exécutable ;
un outil (armar) permettant de créer des archives au format ELF afin de construire des librairies pré-compilées ;
un utilitaire (fromelf) permettant de travailler et d'avoir des informations sur les archives au format ELF telles que la taille du code ou des données.
Enfin, pour ce qui est du débogueur, l'IDE µVision met à disposition un outil intégré permettant de suivre pas à pas l'exécution d'un programme aussi bien en simulé que sur la cible réelle. L'IDE offre aussi un outil pour charger (loader) le code sur la cible suivant différents formats de fichiers binaires compilés.
Si vous souhaitez utiliser la carte NUCLEO pour le développement de vos applications, il vous faut aussi charger le driver Windows ST-LINK/V2.




printf("L'adresse de la variable age est : %p", &age);

Comme notre pointeur pointeurSurAge va contenir l'adresse de la variable age  (qui est de type int  ),
 alors mon pointeur doit être de type int*  !
Si ma variable age avait été de type double  , alors j'aurais dû écrire double *monPointeur  .

Le mot clé STATIC sur une variable au sein d'une fonction l'empêche d'être détruite(comportement normal) à la
fin de la fonction. Donc si la fonction est répéter il y aura une incrémentation (dans le cas d'une fonction qui effectue une opération somme) plutot qu'une répétion (sans STATIC)


Les contantes prédéfines & Les directives préprocesseurs signifie en faite préexécution sur le reste programme. grace au # les instruction sont exécuté avant tout. On le qualifide de préCPU car # sert à effectuer une substituton et n'est pas compilé.

Rendre son code source modulaire ça veut dire le diviser (avec plusieurs *.C et *.H), le rendre le plus clair possible.

Commençons par ajouter un fichier *.C qui contiendra seulement la fonction triple comme ci-dessous.

Notez que dans main.c j'ai l'habitude de garder que la fonction main.

Pour allouer dynamiquement en C++, on utilisera l’opérateur new.
Celui-ci renvoyant une adresse où est crée la variable en question, il
nous faudra un pointeur pour la conserver.
Manipuler ce pointeur, reviendra à manipuler la variable allouée
dynamiquement.
Pour libérer de la mémoire allouée dynamiquement en C++, on
utilisera l’opérateur delete.



int *monPointeur = NULL;
Là, vous avez un pointeur initialisé à NULL  . Comme ça, vous saurez dans la suite de votre programme que votre pointeur ne contient aucune adresse.
Que se passe-t-il ?
Ce code va réserver une case en mémoire comme si vous aviez créé une variable normale.
Cependant, et c'est ce qui change, la valeur du pointeur est faite pour contenir une adresse. L'adresse… d'une autre variable.
Vous savez maintenant comment indiquer l'adresse d'une variable (au lieu de sa valeur) en utilisant le symbole &  ,


 size_t strlen(const char* chaine);
La fonction prend un paramètre de type const char*  : là où sera renvoyée la valeur mais inchangée.  
Le const(  qui signifie constante) fait que la fonction strlen "s'interdit" en quelque sorte de modifier votre chaîne. Quand vous voyez un const  , vous savez que la variable n'est pas modifiée par la fonction, elle est juste lue.


char* strchr(const char* chaine, int caractereARechercher);
La fonction renvoie un pointeur vers le premier caractère qu'elle a trouvé, c'est-à-dire qu'elle renvoie l'adresse (en provenance de la valeur) de ce caractère dans la mémoire. Elle renvoie NULL si elle n'a rien trouvé.



Lorsque vous programmez pour l’embarqué, vous allez compiler et exécuter votre code sur deux machines différentes, qui n’ont pas la même micro-architecture. C’est la grande différence entre la programmation usuelle sur une machine du bureau et la programmation pour l’embarqué ! On parle alors de compilation croisée (cross compilation).


C# : Il existe deux types de classes :
Les classes de plan, qui sont utilisées comme plans pour l'instanciation des objets.
Les classes utilitaires, qui contiennent des méthodes statiques pouvant être appelées directement sur la classe.


On peut trouver une seule case mémoire mais avec deux étiquettes(identificateur) qui lui sont accrochées.
Au niveau du code, on utilise une esperluette ( &  ) pour déclarer une référence(deuxième identificateur) sur une variable.
int& variable(référence);





Il y a globalement deux type de "commandes" DOS : Les commandes gérées par l'invite (for, title...) et les commandes qui sont en fait des .exe, .com ou autre, et qui se situe généralement dans system32 ou dans le répertoire de windows.




Inutile de préciser qu'à cette vitesse le disque ne peut absolument pas être voilé et être assez rigide pour éviter que les plateaux ne vibrent. D'où l'appellation HD Hard Disc (disque dur) par opposition au " floppy disc " (disque souple).
L'espace entre une tête de lecture est infime et la vitesse de la surface du disque par rapport à ces têtes est de l'ordre de 100 km/h.



Il existe 3 grandes familles de drivers :

Le plus courant, le driver en mode caractère: on échange des données de manière itérative. Il est le plus simple à mettre en œuvre, permet de dialoguer avec le périphérique en échangeant un nombre variable d'informations binaires (exemple d’utilisation : port série).

Le driver en mode bloc permet l’échange des informations avec les périphériques uniquement par blocs de données (exemple d’utilisation : le disque dur).

Il est donc spécifique pour manipuler un grand nombre de données.

Quant au driver réseau, il est lui, destiné à contrôler des ressources réseau.




Bon voilà, je veux me lancer dans la programmation d'un compilateur C (compilateur + éditeur de liens bien sur) en C
-J'ai les connaissances de base en assembleur: faire un programme fonctionnel, utilisation de la stack, des procédures et des interruptions
-Et de bonnes connaissances en C et des différentes structures de données (arbre/pile/file/liste chainée/..)
-Utilisation de Lex et Yacc
-Connaissances de base de la chaine de compilation (analyse lexicale/syntaxique/sémantique , relogeage d'adresse, ...) mais d'un point de vue purement théorique :-°
-Connaissances de base en théorie de langages: DFA,NFA,PDA,Grammaires,..
La partie analyse sémantique est la plus complexe : ça comprend la construction d'arbre d'execution, sa décoration, construction d'univers...

















Ce pragma, je l'aime bien, il n'est pas très portable, il sert à dire au compilateur quelle librairie linker.

Au lieu d'aller modifier les propriétés du projet, en cliquant, ou en remplissant le makefile, tu écris directement dans le code quelle librairie il faudra linker.

Pour ma part, je mets souvent ce #pragma a coté de l'include du header de la lib. Ainsi, en 2 ligne, je dis ou est le .h, et quelle librairie associée linker.

















